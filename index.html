<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Trends Dashboard</title>
    <style>
        /* Base styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
            transition: background-color 0.3s, color 0.3s;
            line-height: 1.6;
        }

        /* Dark Mode styles */
        body.dark-mode {
            background-color: #282c34;
            color: #e0e0e0;
        }

        h1 {
            color: #007bff;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 600;
        }

        body.dark-mode h1 {
            color: #61dafb;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 30px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        body.dark-mode .controls {
            background-color: #3a3f4a;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .controls label {
            font-weight: bold;
            color: #555;
        }

        body.dark-mode .controls label {
            color: #bbb;
        }

        .controls select,
        .controls input[type="text"],
        .controls button {
            padding: 10px 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1rem;
            background-color: #fff;
            color: #333;
            transition: all 0.3s ease;
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
        }

        body.dark-mode .controls select,
        body.dark-mode .controls input[type="text"],
        body.dark-mode .controls button {
            background-color: #4a4f5d;
            border-color: #555;
            color: #e0e0e0;
        }

        .controls select:focus,
        .controls input[type="text"]:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
            outline: none;
        }

        .controls button {
            cursor: pointer;
            background-color: #28a745;
            color: white;
            border: none;
            font-weight: bold;
        }

        body.dark-mode .controls button {
            background-color: #20c997;
        }

        .controls button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        #chart-container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            position: relative; /* Needed for tooltip positioning */
        }

        body.dark-mode #chart-container {
            background-color: #3a3f4a;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        #weatherChart {
            display: block; /* Remove extra space below canvas */
            width: 100%; /* Make canvas responsive to its container */
            height: auto;
            max-height: 400px; /* Limit max height */
            transition: opacity 0.3s ease-in-out; /* Smooth fade for chart updates */
        }
        
        .chart-title {
            text-align: center;
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #555;
            font-weight: 500;
        }

        body.dark-mode .chart-title {
            color: #bbb;
        }

        .no-data-message {
            text-align: center;
            color: #dc3545;
            font-weight: bold;
            margin-top: 20px;
            font-size: 1.1em;
            padding: 10px;
            border: 1px solid #dc3545;
            background-color: #f8d7da;
            border-radius: 5px;
        }

        body.dark-mode .no-data-message {
            background-color: #6a282f;
            color: #f7b7bb;
            border-color: #f7b7bb;
        }

        #chart-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            pointer-events: none; /* Allows mouse events to pass through to canvas */
            white-space: nowrap;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            .controls select,
            .controls input[type="text"],
            .controls button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>Weather Trends Dashboard</h1>

    <div class="controls">
        <label for="city-select">Select City:</label>
        <select id="city-select"></select>

        <label for="city-search">Search City:</label>
        <input type="text" id="city-search" placeholder="Type city name...">
        
        <button id="refresh-data-button">Refresh Data</button>
        <button id="dark-mode-toggle">Toggle Dark Mode</button>
    </div>

    <div id="chart-container">
        <h2 class="chart-title" id="current-city-title">Average Monthly Temperatures</h2>
        <canvas id="weatherChart"></canvas>
        <p class="no-data-message" style="display: none;">No data available for the selected city or search criteria.</p>
        <div id="chart-tooltip"></div>
    </div>

    <script>
        // Raw JSON data - simulating data.json fetch
        const RAW_JSON_DATA = `{"cities":[{"name":"New York","tems":[12,15,18,19,16,22,19,18,14,12,11,13]},{"name":"London","tems":[11,13,17,18,20,21,20,18,17,14,12,10]},{"name":"Singapore","tems":[13,14,16,18,20,22,19,18,17,15,14,13]}]}`;
        
        let allCitiesData;
        let chartCanvas, chartCtx;
        let citySelect, citySearchInput, darkModeToggle, refreshDataButton;
        let currentCityTitle;
        let noDataMessage;
        let chartTooltip; // New
        let dataPointsCoordinates = []; // New, stores {x, y, temp, month} for tooltips

        const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        const CHART_TRANSITION_DURATION = 300; // ms, matches CSS transition duration
        const TOOLTIP_HOVER_RADIUS = 15; // px

        document.addEventListener('DOMContentLoaded', init);

        async function init() {
            // Get DOM elements
            chartCanvas = document.getElementById('weatherChart');
            chartCtx = chartCanvas.getContext('2d');
            citySelect = document.getElementById('city-select');
            citySearchInput = document.getElementById('city-search');
            darkModeToggle = document.getElementById('dark-mode-toggle');
            refreshDataButton = document.getElementById('refresh-data-button'); // New
            currentCityTitle = document.getElementById('current-city-title');
            noDataMessage = document.querySelector('.no-data-message');
            chartTooltip = document.getElementById('chart-tooltip'); // New

            applyDarkModePreference(); // Apply dark mode preference on load

            // Set initial canvas dimensions and attach resize listener
            resizeChartCanvas();
            window.addEventListener('resize', resizeChartCanvas);

            // Fetch initial data
            try {
                allCitiesData = await fetchData(); // Use await here
            } catch (error) {
                console.error("Error fetching initial data:", error);
                allCitiesData = [];
            }

            // Initial population and chart draw (without transition delay for first load)
            populateCitySelect(allCitiesData);
            if (allCitiesData.length > 0) {
                const initialCity = allCitiesData[0];
                citySelect.value = initialCity.name; // Ensure dropdown reflects the first city
                drawChart(initialCity.tems, initialCity.name);
            } else {
                displayNoDataMessage(true);
            }

            // Event Listeners
            citySelect.addEventListener('change', onCitySelectChange);
            citySearchInput.addEventListener('input', filterCities);
            darkModeToggle.addEventListener('click', toggleDarkMode);
            refreshDataButton.addEventListener('click', refreshData); // New
            chartCanvas.addEventListener('mousemove', handleMouseMove); // New
            chartCanvas.addEventListener('mouseleave', handleMouseLeave); // New
        }

        // Simulate data fetching
        async function fetchData() {
            // In a real application, this would be:
            // const response = await fetch('data.json');
            // const data = await response.json();
            // return data.cities;

            // For this exercise, we simulate a network delay and parse the local string.
            await new Promise(resolve => setTimeout(resolve, 300)); // Simulate network latency
            return JSON.parse(RAW_JSON_DATA).cities;
        }

        // Apply dark mode preference from localStorage
        function applyDarkModePreference() {
            const isDarkMode = localStorage.getItem('darkMode');
            if (isDarkMode === 'true') {
                document.body.classList.add('dark-mode');
            }
        }

        function resizeChartCanvas() {
            const container = chartCanvas.parentElement;
            const dpi = window.devicePixelRatio || 1;
            
            // Subtract padding of the #chart-container (20px left + 20px right)
            const clientWidth = container.clientWidth - 40; 
            
            chartCanvas.style.width = clientWidth + 'px';
            chartCanvas.style.height = (clientWidth * 0.5) + 'px'; // Maintain 2:1 aspect ratio

            chartCanvas.width = clientWidth * dpi;
            chartCanvas.height = (clientWidth * 0.5) * dpi;
            
            chartCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform before scaling
            chartCtx.scale(dpi, dpi); 

            // Redraw chart after resize to ensure it fits new dimensions
            // Use triggerChartUpdate to ensure correct state after resize
            triggerChartUpdate();
        }

        function populateCitySelect(citiesToDisplay) {
            citySelect.innerHTML = ''; // Clear existing options
            if (citiesToDisplay.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No cities found';
                citySelect.appendChild(option);
                citySelect.disabled = true;
                return;
            }
            citySelect.disabled = false;

            citiesToDisplay.forEach(city => {
                const option = document.createElement('option');
                option.value = city.name;
                option.textContent = city.name;
                citySelect.appendChild(option);
            });
        }

        function filterCities() {
            const searchTerm = citySearchInput.value.toLowerCase();
            const filtered = allCitiesData.filter(city => 
                city.name.toLowerCase().includes(searchTerm)
            );

            populateCitySelect(filtered);

            // Logic to handle selection after filtering
            const currentSelectedCity = citySelect.value;
            const isCurrentSelectedInFiltered = filtered.some(city => city.name === currentSelectedCity);

            if (!isCurrentSelectedInFiltered && filtered.length > 0) {
                // If previously selected city is filtered out, select the first available
                citySelect.value = filtered[0].name;
            } else if (filtered.length === 0) {
                citySelect.value = ''; // No city to select
            } else {
                // Keep the current selection if it's still valid
                citySelect.value = currentSelectedCity;
            }
            
            // Update chart based on the new selection
            triggerChartUpdate();
        }

        // Event handler for city select change - simply triggers the update process
        function onCitySelectChange() {
            triggerChartUpdate();
        }

        // Function to handle chart updates with fade transition
        function triggerChartUpdate() {
            chartCanvas.style.opacity = 0; // Start fade-out
            chartTooltip.style.opacity = 0; // Hide tooltip during transition

            setTimeout(() => {
                const selectedCityName = citySelect.value;
                const selectedCity = allCitiesData.find(city => city.name === selectedCityName);

                if (selectedCity && selectedCity.tems && selectedCity.tems.length > 0) {
                    displayNoDataMessage(false);
                    drawChart(selectedCity.tems, selectedCity.name);
                } else {
                    displayNoDataMessage(true);
                    // Clear chart content if no data
                    chartCtx.clearRect(0, 0, chartCanvas.width / (window.devicePixelRatio || 1), chartCanvas.height / (window.devicePixelRatio || 1));
                    currentCityTitle.textContent = "Average Monthly Temperatures";
                }
                chartCanvas.style.opacity = 1; // Fade-in the new chart
            }, CHART_TRANSITION_DURATION);
        }

        function displayNoDataMessage(show) {
            noDataMessage.style.display = show ? 'block' : 'none';
            chartCanvas.style.display = show ? 'none' : 'block';
            currentCityTitle.style.display = show ? 'none' : 'block';
        }

        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            // Save preference to localStorage
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
            // Redraw chart to update colors based on new dark mode state
            triggerChartUpdate(); 
        }

        // New function to refresh data from source
        async function refreshData() {
            console.log("Refreshing data...");
            // Start transition immediately
            chartCanvas.style.opacity = 0;
            chartTooltip.style.opacity = 0; // Hide tooltip immediately

            try {
                allCitiesData = await fetchData();
                populateCitySelect(allCitiesData);
                // Ensure the currently selected city (or first available) is drawn
                // `populateCitySelect` might change `citySelect.value` if the old selection is gone.
                // Call triggerChartUpdate after a delay to allow fade out before new data renders.
                setTimeout(() => {
                    triggerChartUpdate();
                }, CHART_TRANSITION_DURATION);
            } catch (error) {
                console.error("Error refreshing data:", error);
                // Ensure chart fades back in even if error occurs
                chartCanvas.style.opacity = 1;
            }
        }

        function drawChart(temperatures, cityName) {
            if (!temperatures || temperatures.length === 0) {
                displayNoDataMessage(true);
                return;
            }
            displayNoDataMessage(false);

            currentCityTitle.textContent = `Average Monthly Temperatures for ${cityName}`;

            const isDarkMode = document.body.classList.contains('dark-mode');
            
            // Colors for chart elements based on theme
            const chartTextColor = isDarkMode ? '#e0e0e0' : '#333';
            const chartGridColor = isDarkMode ? '#555' : '#e0e0e0';
            const chartLineColor = isDarkMode ? '#61dafb' : '#007bff';
            const chartPointColor = isDarkMode ? '#20c997' : '#ffc107'; 
            const chartAxisColor = isDarkMode ? '#bbb' : '#555';

            chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height); // Clear the entire drawing buffer

            const dpi = window.devicePixelRatio || 1;
            const cssCanvasWidth = chartCanvas.width / dpi;
            const cssCanvasHeight = chartCanvas.height / dpi;

            const padding = 60; // Padding for the chart area within the canvas (in CSS pixels)
            const chartWidth = cssCanvasWidth - 2 * padding;
            const chartHeight = cssCanvasHeight - 2 * padding;

            // Find min and max temperatures for y-axis scaling
            const minTemp = Math.min(...temperatures);
            const maxTemp = Math.max(...temperatures);
            let displayMinTemp = minTemp - (maxTemp - minTemp) * 0.1; 
            let displayMaxTemp = maxTemp + (maxTemp - minTemp) * 0.1;

            if (minTemp === maxTemp) {
                displayMinTemp = minTemp - 5;
                displayMaxTemp = maxTemp + 5;
            }
            const displayTempRange = displayMaxTemp - displayMinTemp;
            const yAxisScale = chartHeight / displayTempRange;

            // Draw X and Y axes
            chartCtx.strokeStyle = chartAxisColor;
            chartCtx.lineWidth = 2;

            // Y-axis
            chartCtx.beginPath();
            chartCtx.moveTo(padding, padding);
            chartCtx.lineTo(padding, padding + chartHeight);
            chartCtx.stroke();

            // X-axis
            chartCtx.beginPath();
            chartCtx.moveTo(padding, padding + chartHeight);
            chartCtx.lineTo(padding + chartWidth, padding + chartHeight);
            chartCtx.stroke();

            chartCtx.fillStyle = chartTextColor;
            chartCtx.font = '14px Arial'; // Font size in CSS pixels
            chartCtx.textAlign = 'center';
            chartCtx.textBaseline = 'middle';

            // Draw X-axis labels (Months) and vertical grid lines
            const xStep = chartWidth / (months.length - 1); // Distance between points
            months.forEach((month, i) => {
                const x = padding + i * xStep;
                chartCtx.fillText(month, x, padding + chartHeight + 25);
                
                // Draw vertical grid lines
                if (i > 0 && i < months.length) { 
                    chartCtx.strokeStyle = chartGridColor;
                    chartCtx.lineWidth = 0.5;
                    chartCtx.beginPath();
                    chartCtx.moveTo(x, padding + chartHeight);
                    chartCtx.lineTo(x, padding);
                    chartCtx.stroke();
                }
            });

            // Draw Y-axis labels (Temperatures) and horizontal grid lines
            const numYLabels = 5; 
            const tempInterval = displayTempRange / (numYLabels - 1);

            chartCtx.textAlign = 'right';
            for (let i = 0; i < numYLabels; i++) {
                const tempValue = displayMinTemp + i * tempInterval;
                const y = padding + chartHeight - ((tempValue - displayMinTemp) * yAxisScale);
                
                if (y < padding - 5 || y > padding + chartHeight + 5) continue;

                chartCtx.fillText(tempValue.toFixed(0) + '°C', padding - 10, y);
                
                // Draw horizontal grid lines
                chartCtx.strokeStyle = chartGridColor;
                chartCtx.lineWidth = 0.5;
                chartCtx.beginPath();
                chartCtx.moveTo(padding, y);
                chartCtx.lineTo(padding + chartWidth, y);
                chartCtx.stroke();
            }
            
            // Draw the line chart
            chartCtx.beginPath();
            chartCtx.strokeStyle = chartLineColor;
            chartCtx.lineWidth = 3;
            chartCtx.lineJoin = 'round';
            chartCtx.lineCap = 'round';

            // Reset dataPointsCoordinates for new chart
            dataPointsCoordinates = [];

            temperatures.forEach((temp, i) => {
                const x = padding + i * xStep;
                const y = padding + chartHeight - ((temp - displayMinTemp) * yAxisScale);

                if (i === 0) {
                    chartCtx.moveTo(x, y);
                } else {
                    chartCtx.lineTo(x, y);
                }
                // Store data point coordinates for tooltip
                dataPointsCoordinates.push({ x: x, y: y, temp: temp, month: months[i] });
            });
            chartCtx.stroke();

            // Draw data points after the line
            dataPointsCoordinates.forEach(point => { // Use stored points
                chartCtx.fillStyle = chartPointColor;
                chartCtx.strokeStyle = chartLineColor; 
                chartCtx.lineWidth = 1.5;
                chartCtx.beginPath();
                chartCtx.arc(point.x, point.y, 5, 0, Math.PI * 2); 
                chartCtx.fill();
                chartCtx.stroke();
            });
        }

        // New function to handle mouse movement for tooltip
        function handleMouseMove(event) {
            if (!chartCanvas || !dataPointsCoordinates || dataPointsCoordinates.length === 0) return;

            const rect = chartCanvas.getBoundingClientRect();
            // Mouse coordinates relative to the canvas CSS pixel size
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            let tooltipVisible = false;
            for (const point of dataPointsCoordinates) {
                // Calculate distance between mouse and data point
                const distance = Math.sqrt(Math.pow(mouseX - point.x, 2) + Math.pow(mouseY - point.y, 2));
                if (distance < TOOLTIP_HOVER_RADIUS) {
                    chartTooltip.textContent = `${point.month}: ${point.temp}°C`;
                    // Position tooltip relative to the chart-container, which is 'relative'
                    chartTooltip.style.left = `${mouseX + 15}px`;
                    chartTooltip.style.top = `${mouseY + 15}px`;
                    chartTooltip.style.opacity = 1;
                    tooltipVisible = true;
                    break;
                }
            }

            if (!tooltipVisible) {
                chartTooltip.style.opacity = 0;
            }
        }

        // New function to hide tooltip when mouse leaves canvas
        function handleMouseLeave() {
            chartTooltip.style.opacity = 0;
        }
    </script>
</body>
</html>